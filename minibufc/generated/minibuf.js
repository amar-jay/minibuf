"use strict";
// Generated by minibufc
exports.__esModule = true;
exports.GovtSerialize = exports.GovtParse = exports.ConfigSerialize = exports.ConfigParse = exports.VectorSerialize = exports.VectorParse = void 0;
var floatPrecision = 3;
function VectorParse(str) {
    var start = str.indexOf('[');
    if (start === -1)
        throw new Error('Invalid format');
    var end = str.indexOf(']', start);
    if (end === -1)
        throw new Error('Invalid format');
    var count = parseInt(str.slice(start + 1, end));
    var values = str.slice(end + 1).split(';');
    var result = {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    for (var i = 0; i < Math.min(count, values.length); i++) {
        if (i === 0) {
            result.x = parseFloat(values[i]);
        }
        if (i === 1) {
            result.y = parseFloat(values[i]);
        }
        if (i === 2) {
            result.z = parseFloat(values[i]);
        }
    }
    return result;
}
exports.VectorParse = VectorParse;
function VectorSerialize(obj) {
    var count = 3;
    var str = "[".concat(count, "]");
    str += "".concat(obj.x.toFixed(floatPrecision));
    str += ';';
    str += "".concat(obj.y.toFixed(floatPrecision));
    str += ';';
    str += "".concat(obj.z.toFixed(floatPrecision));
    return str;
}
exports.VectorSerialize = VectorSerialize;
function ConfigParse(str) {
    var start = str.indexOf('[');
    if (start === -1)
        throw new Error('Invalid format');
    var end = str.indexOf(']', start);
    if (end === -1)
        throw new Error('Invalid format');
    var count = parseInt(str.slice(start + 1, end));
    var values = str.slice(end + 1).split(';');
    var result = {
        auto_restart: false,
        id: 0,
        user_name: '',
        score: 6000.000
    };
    for (var i = 0; i < Math.min(count, values.length); i++) {
        if (i === 0) {
            result.auto_restart = values[i] === 'T';
        }
        if (i === 1) {
            result.id = parseInt(values[i]);
        }
        if (i === 2) {
            result.user_name = values[i];
        }
        if (i === 3) {
            result.score = parseFloat(values[i]);
        }
    }
    return result;
}
exports.ConfigParse = ConfigParse;
function ConfigSerialize(obj) {
    var count = 4;
    var str = "[".concat(count, "]");
    str += "".concat(obj.auto_restart ? 'T' : 'F');
    str += ';';
    str += "".concat(obj.id);
    str += ';';
    str += "".concat(obj.user_name);
    str += ';';
    str += "".concat(obj.score.toFixed(floatPrecision));
    return str;
}
exports.ConfigSerialize = ConfigSerialize;
function GovtParse(str) {
    var start = str.indexOf('[');
    if (start === -1)
        throw new Error('Invalid format');
    var end = str.indexOf(']', start);
    if (end === -1)
        throw new Error('Invalid format');
    var count = parseInt(str.slice(start + 1, end));
    var values = str.slice(end + 1).split(';');
    var result = {
        minister_count: 0,
        president_name: '',
        president_term: 0,
        prime_minister_name: '',
        vote_count: 0.0
    };
    for (var i = 0; i < Math.min(count, values.length); i++) {
        if (i === 0) {
            result.minister_count = parseInt(values[i]);
        }
        if (i === 1) {
            result.president_name = values[i];
        }
        if (i === 2) {
            result.president_term = parseInt(values[i]);
        }
        if (i === 3) {
            result.prime_minister_name = values[i];
        }
        if (i === 4) {
            result.vote_count = parseFloat(values[i]);
        }
    }
    return result;
}
exports.GovtParse = GovtParse;
function GovtSerialize(obj) {
    var count = 5;
    var str = "[".concat(count, "]");
    str += "".concat(obj.minister_count);
    str += ';';
    str += "".concat(obj.president_name);
    str += ';';
    str += "".concat(obj.president_term);
    str += ';';
    str += "".concat(obj.prime_minister_name);
    str += ';';
    str += "".concat(obj.vote_count.toFixed(floatPrecision));
    return str;
}
exports.GovtSerialize = GovtSerialize;
