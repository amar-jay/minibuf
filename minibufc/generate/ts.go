package generate

import (
	"fmt"
	"strings"

	"github.com/amar-jay/minibuf/parser"
)

/**
```ts
import { VectorParse, ConfigParse } from "./minibuf.ts";

const str = "[3]1.5;2.3;4.1";

try {
  const v = VectorParse(str);
  // parse Config
  const conf = ConfigParse(str);
} catch (error) {
  console.error(error);
}
```
*/

func TS(p *parser.Parser) string {
	return generateTS(p)
}

func generateTS(p *parser.Parser) string {
	var sb strings.Builder
	sb.WriteString("// Generated by minibufc\n\n")
	if val, ok := p.Config["float_precision"]; ok {
		if i, ok := val.(int); ok {
			sb.WriteString(fmt.Sprintf("const floatPrecision = %d;\n\n", i))
		} else {
			sb.WriteString("const floatPrecision = 3;\n\n")
		}
	} else {
		sb.WriteString("const floatPrecision = 3;\n\n")
	}
	for _, schema := range p.Schemas {
		sb.WriteString(fmt.Sprintf("export interface %s {\n", schema.Name))
		for _, field := range schema.Fields {
			tsType := tsType(field.DataType)
			sb.WriteString(fmt.Sprintf("  %s: %s;\n", field.Name, tsType))
		}
		sb.WriteString("}\n\n")
	}
	for _, schema := range p.Schemas {
		sb.WriteString(fmt.Sprintf("export function %sParse(str: string): %s {\n", schema.Name, schema.Name))
		sb.WriteString("  const start = str.indexOf('[');\n")
		sb.WriteString("  if (start === -1) throw new Error('Invalid format');\n")
		sb.WriteString("  const end = str.indexOf(']', start);\n")
		sb.WriteString("  if (end === -1) throw new Error('Invalid format');\n")
		sb.WriteString("  const count = parseInt(str.slice(start + 1, end));\n")
		sb.WriteString("  const values = str.slice(end + 1).split(';');\n")
		sb.WriteString(fmt.Sprintf("  const result: %s = {\n", schema.Name))
		// set defaults
		for _, field := range schema.Fields {
			if def, ok := schema.Defaults[field.Name]; ok {
				sb.WriteString(fmt.Sprintf("    %s: ", field.Name))
				switch field.DataType {
				case "bool":
					if def.(bool) {
						sb.WriteString("true,\n")
					} else {
						sb.WriteString("false,\n")
					}
				case "number":
					sb.WriteString(fmt.Sprintf("%d,\n", def.(int)))
				case "float":
					sb.WriteString(fmt.Sprintf("%.3f,\n", def.(float64)))
				case "string":
					sb.WriteString(fmt.Sprintf("'%s',\n", def.(string)))
				}
			} else {
				// default defaults
				switch field.DataType {
				case "bool":
					sb.WriteString(fmt.Sprintf("    %s: false,\n", field.Name))
				case "number":
					sb.WriteString(fmt.Sprintf("    %s: 0,\n", field.Name))
				case "float":
					sb.WriteString(fmt.Sprintf("    %s: 0.0,\n", field.Name))
				case "string":
					sb.WriteString(fmt.Sprintf("    %s: '',\n", field.Name))
				}
			}
		}
		sb.WriteString("  };\n")
		sb.WriteString("  for (let i = 0; i < Math.min(count, values.length); i++) {\n")
		for idx, field := range schema.Fields {
			sb.WriteString(fmt.Sprintf("    if (i === %d) {\n", idx))
			switch field.DataType {
			case "bool":
				sb.WriteString(fmt.Sprintf("      result.%s = values[i] === 'T';\n", field.Name))
			case "number":
				sb.WriteString(fmt.Sprintf("      result.%s = parseInt(values[i]);\n", field.Name))
			case "float":
				sb.WriteString(fmt.Sprintf("      result.%s = parseFloat(values[i]);\n", field.Name))
			case "string":
				sb.WriteString(fmt.Sprintf("      result.%s = values[i];\n", field.Name))
			}
			sb.WriteString("    }\n")
		}
		sb.WriteString("  }\n")
		sb.WriteString("  return result;\n")
		sb.WriteString("}\n\n")
		// serialize
		sb.WriteString(fmt.Sprintf("export function %sSerialize(obj: %s): string {\n", schema.Name, schema.Name))
		sb.WriteString(fmt.Sprintf("  const count = %d;\n", len(schema.Fields)))
		sb.WriteString("  let str = `[${count}]`;\n")
		for idx, field := range schema.Fields {
			if idx > 0 {
				sb.WriteString("  str += ';';\n")
			}
			sb.WriteString("  str += `")
			switch field.DataType {
			case "bool":
				sb.WriteString(fmt.Sprintf("${obj.%s ? 'T' : 'F'}", field.Name))
			case "number":
				sb.WriteString(fmt.Sprintf("${obj.%s}", field.Name))
			case "float":
				sb.WriteString(fmt.Sprintf("${obj.%s.toFixed(floatPrecision)}", field.Name))
			case "string":
				sb.WriteString(fmt.Sprintf("${obj.%s}", field.Name))
			}
			sb.WriteString("`;\n")
		}
		sb.WriteString("  return str;\n")
		sb.WriteString("}\n\n")
	}
	return sb.String()
}

func tsType(dt string) string {
	switch dt {
	case "bool":
		return "boolean"
	case "number":
		return "number"
	case "float":
		return "number"
	case "string":
		return "string"
	}
	return "any"
}
